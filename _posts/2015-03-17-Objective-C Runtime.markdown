---
layout: post
title:  "Objective-C Runtime"
date:   2015-3-17 11:23:32
categories: iOS
---

#Objective-C Runtime杂谈#引言•	Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理. 优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。•	这种在运行时期处理的系统就是Objc Runtime•	Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。Obj Runtime的两个版本•	Objective-C运行时系统有两个已知版本:早期版本（Legacy）和现行版本（Modern）。•	在现行版本中,最显著的新特性就是实例变量是"健壮“(non-fragile)的:	在早期版本中,如果您改变类中实例变量的布局,您必须重新编译该类的所有子类。	在现行版本中,如果您改变类中实例变量的布局,您无需重新编译该类的任何子类。•	此外,现行版本支持声明property的synthesis属性器。•	目前iPhone 程序和 Mac OS X v10.5 及以后的系统中的 64 位程序使用的都是 Objective-C 运行时系统的现行版 本。其它情况(Mac OS X 系统中的 32 位程序)使用的是早期版本。与runtime system交互方式1.通过Objective-C源代码大部分情况下我们只需要关注OC代码的编写和编译，当编译OC类和方法时,编译器为实现语言动态特性将自动创建一些数据结构和函数，这些数据结构包含类定义和协议类定义中的信息，运行时系统的主要功能就是根据源代码中的表达式发送消息。例如：[receiver message]会编译成objc_msgSend(receiver, selector)receiver将要如何响应这条消息，那就要看运行时发生的情况来决定2.通过类NSObject的方法Cocoa程序中绝大部分类都是NSObject类的子类,所以大部分都继承了NSObject类的方法,也继承了NSObject的行为(NSProxy类是个例外)。NSProxy是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，有的NSObject中的方法起到了抽象接口的作用，比如description方法需要你重载它并为你定义的类提供描述内容。NSObject还有些方法能在运行时获得类的信息，并检查一些特性，比如class返回对象的类；isKindOfClass:和isMemberOfClass:则检查对象是否在指定的类继承体系中；respondsToSelector:检查对象能否响应指定的消息；conformsToProtocol:检查对象是否实现了指定协议类的方法；methodForSelector:则返回指定方法实现的地址。3．通过Runtime函数Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了NSObject类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在Objective-C Runtime Reference中有对 Runtime 函数的详细文档#类与对象在介绍runtime一些实用技术之前不得不说一下OC中，类与对象。##对象Objective-C中,类和对象的在底层是以数据结构来表示.其中对象是通过struct objc_object结构实现typedef struct objc_object *id;struct objc_object {    Class isa  OBJC_ISA_AVAILABILITY;};对象在运行时候,会产生如下图的结构形式 从对象内存形式上来看.对象内的变量成员,是从祖类继承而来(子成父业),在对象内部生成副本.从对象的内存组织来看,对象本身并不关心行为(对象的方法或实例方法),重点都在数据的组织上.对象的都有一个isa实例变量,它是从继承层次最高的NSObject继承而来，isa是表示对象的关键. ###isa指针Objective-C是一门面向对象的编程语言。每一个对象都是一个类的实例。在Objective-C语言的内部，每一个对象都有一个名为isa的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。实质上,同一个类的实例,都指向同一个类对象(类也是一种特殊对象).类中包含了实例方法,也就是说,同一个类的所有实例共用了这些实例方法.消息就是发送给对象,对象转交给其isa指向类去处理.这种现象类似于当下火热的云计算. Objective-C的这种设计,既可以友好地实现面向对象,又可以有效地节约内存.降低冗余数据.对象对方法的调用是通过isa间接去调用,这样就造成了方法调用的动态性,主要原因是:1.一个对象并不晓得它能否应答一个方法,它本身既不包含方法的实现,也不包含有方法的指针,而是间接通过isa转到自己的类才能知道2.类中的实例方法是以链表形式存在,运行时候,可以修改链表中的实例方法,即可以增删改查,这与C中的函数默认都是extern的不同从上面的分析,isa的意义就更加重大,倘若没有isa,一个对象就跟char,int类型等没啥区别了,不具备回应消息的本领.###ClassClass其实是一个指向objc_class结构体的指针typedef struct objc_class *Class; 可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。这里可以看到objc_class中也有一个isa对象，这是因为一个 Class 类本身同时也是一个对象，当你调用一个类方法,就像[NSObject alloc],你实质上是给类对象发送了一个消息.大家都知道所有的对象都是由其对应的类实例化而来，殊不知类本身也是一种对象（万物皆对象）Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是苹果公司说的类对象(class object),他是一个单例(singleton), 而我们在java,C++等语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是什么呢？我们知道Objective-C是门动态的语言，因此程序里的所有实例对象(instace object)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。既然类对象也是一种对象,那么它也会有自己的行为,这种行为称作类方法.与一般的类实例一样,类对象也不具备处理类方法的能力,也是要借助isa找到它所属的类,既元类,去调用类方法,类对象本身也是专注于数据的存储和布局形式. 元类(metaclass)也是一个对象，那么元类的isa指针又指向哪里呢？为了设计上的完整，所有的元类的isa指针都会指向一个根元类(root metaclass)。根元类(root metaclass)本身的isa指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的isa指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有isa指针。 该图中，最让人困惑的莫过于Root Class了。在实现中，Root Class是指NSObject，我们可以从图中看出：1. NSObject类包括它的对象实例方法。2. NSObject的元类包括它的类方法，例如alloc方法。3. NSObject的元类继承自NSObject类。4. 一个NSObject的类中的方法同时也会被NSObject的子类在查找方法时找到。###消息Objc 中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。objc_msgSend(receiver, selector)其实在 objc_msgSend执行时从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：1. 检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会retain, release 这些函数了。2. 检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。3. 如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。4. 如果 cache 找不到就找一下方法分发表。5. 如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。6. 如果还找不到就要开始进入动态方法解析了，后面会提到。PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。 ###Cachetypedef struct objc_cache *Cache Cache为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找。Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。###动态方法解析@dynamic @synthesizedynamic关键字在类的实现文件中修饰一个属性：@dynamic propertyName;这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成setPropertyName:和propertyName方法，而需要我们动态提供。可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作： 上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 Type Encoding##消息转发 ###重定向在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载- (id)forwardingTargetForSelector:(SEL)aSelector方法替换消息的接受者为其他对象： 消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，不过千万别返回self，因为那样会死循环。###转发当动态方法解析不作处理返回NO时，消息转发机制会被触发。在这时forwardInvocation:方法会被执行，我们可以重写这个方法来定义我们的转发逻辑： 该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。这里需要注意的是参数anInvocation是从哪的来的呢？其实在forwardInvocation:消息发送前，Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。所以我们在重写forwardInvocation:的同时也要重写methodSignatureForSelector:方法，否则会抛异常。转发和多继承转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。 这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中Warrior和Diplomat没有继承关系，但是Warrior将negotiate消息转发给了Diplomat后，就好似Diplomat是Warrior的超类一样。消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。替代者对象(Surrogate Objects)转发不仅能模拟多继承，也能使轻量级对象代表重量级对象。弱小的女人背后是强大的男人，毕竟女人遇到难题都把它们转发给男人来做了。这里有一些适用案例，可以参看官方文档。Objective-C Associated Objects（关联对象）因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。相对的，对象的方法定义都保存在类的可变区域中。在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObjects这些方法以键值对的形式动态地向对象添加、获取或删除关联值  通常推荐key使用static char类型——使用指针或许更好 ###移除关联对象一种方法是试图在某个时刻调用objc_removeAssociatedObjects()函数来移除关联对象，然而，根据苹果文档描述，你不大可能有需求要自己去调用：这个函数的主要目的是很容易的让对象恢复成它“原始状态”，你不应该使用它来移除关联的对象，因为它也会移除掉包括其他地方加入的全部的关联对象。所以一般你只需要通过调用objc_setAssociatedObject并传入nil值来清除关联值。在前面提到了，对象运行时无法动态给对象增加成员变量, Associated Objects（关联对象）会为每个类创建一个ObjectAssociationMap实例，每个类通过联合存储模式保存的键值对也都保存在ObjectAssociationMap实例中。变相地给对象增加成员变量Associated Objects优缺点1、优点最大的优点，在于它能通过灵活的方式实现为类增加属性。2、缺点效率低，使用单条机器指令就可以访问真正的实例变量，但是访问存储在映射表中的值需要多个函数调用，效率问题还是需要注意的。Method Swizzling之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。class_replaceMethod 替换类方法的定义method_exchangeImplementations 交换2个方法的实现method_setImplementation 设置1个方法的实现 上面的代码通过添加一个Tracking类别到UIViewController类中，将UIViewController类的viewWillAppear:方法和Tracking类别中xxx_viewWillAppear:方法的实现相互调换。Swizzling 应该在+load方法中实现，因为+load是在一个类最开始加载时调用。dispatch_once是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。总结深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 Method Swizzling 等。参考博客
* http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/* http://husbandman.diandian.com/post/2012-08-17/40036035008* http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/* http://blog.csdn.net/wzzvictory/article/details/8592492* http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/* http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/