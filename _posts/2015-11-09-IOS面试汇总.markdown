---
layout: post
title:  "IOS-面试汇总"
date:   2015-11-08 10:23:32
categories: IOS
---

##1. abcdefasdefwefwefw中adc出现的次数
hashmap

##2. 10个员工中快速找出 年纪最大的员工
`堆排序`

堆排序 (Heap 80忱) 就是利用堆(假设利用大顶堆)进行排序的方法。它的基本 思想是, 将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根 结点。将官移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大 值) .然后将剩余的 n-1 个序列重新构造成一个堆,这样就刽寻到 n 个元素中的次小 值。如此反复执行, 便能得到一个有序序列了。

##3. 2万个员工中取年纪最大的前10个
* 快速排序
* 堆排序
 
##4. map和NSdic的底层实现
map `红黑树`
`红黑树`本质上就是一棵二叉查找树

##5. http协议中 判断用户头像是否有更新的方法有那些
If-None-Match和`ETag`一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(`ETag`的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和`Etag`

##6. http中文件断点下载的实现机制
实际上断点续传的实现非常简单，只要在请求中加一个Range字段就可以了。 
假如一个文件有1000个字节，那么其范围就是0-999，则： 
Range: bytes=500-      表示读取该文件的500-999字节，共500字节。 
Range: bytes=500-599   表示读取该文件的500-599字节，共100字节。 
Range还有其它几种写法，但上面这两种是最常用的，对于断点续传也足矣了。如果HTTP请求中包含Range字段，那么服务器会返回206（Partial Content），同时HTTP头中也会有一个相应的Content-Range字段，类似下面的格式：
Content-Range: bytes 500-999/1000 
Content-Range字段说明服务器返回了文件的某个范围及文件的总长度。这时Content-Length字段就不是整个文件的大小了，而是对应文件这个范围的字节数，这一点一定要注意。

##7. 怎么与服务器商定可变参数的协议
参数前带个标示

##8. iOS用户响应者链剖析
[响应链]简单来说就是:一级一级的找到响应的视图,如果没有就传给UIWindow实例和UIApplication实例,要是他们也处理不了,就丢弃这次事件...

[响应链]: http://www.cnblogs.com/mcj-coding/p/3569908.html

##9. instrument中检测图片透明度
coreAnimation

##10. IOS混编C++ C++中如果有数组越界了 怎么快速定位
lldb

##11. IOS中野指针怎么快速定位
IOS提供了一个环境变量设置来帮忙定位错误位置的信息描述：NSZombieEnabled ，就是当设置NSZombieEnabled环境变量后，一个对象销毁时会被转化为_NSZombie，设置NSZombieEnabled后，当你向一个已经释放的对象发送消息，这个对象就不会向之前那样Crash或者产生一个难以理解的行为，而是放出一个错误消息，然后以一种可预测的可以产生debug断点的方式消失， 因此我们就可以找到具体或者大概是哪个对象被错误的释放了。

##12. IOS中app切到后台后,怎么实现的继续导航
[application beginBackgroundTaskWithExpirationHandler:]

##13. IOS 推送机制
Apple Push Notification Service
1. 首先是应用程序注册消息推送。
2. IOS跟APNS Server要deviceToken。应用程序接受deviceToken。
3. 应用程序将deviceToken发送给PUSH服务端程序。
4. 服务端程序向APNS服务发送消息。
5. APNS服务将消息发送给iPhone应用程序。
 
##14. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析
方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n * le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n * lg10)。所以总的时间复杂度，是O(n * le)与O(n * lg10)中较大的哪一个。

##15. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？
方案1：这题用trie树比较合适，hash_map也应该能行。
![image](https://github.com/hong4cong/hong4cong.github.io/raw/master/images/2015.11.09/d62a6059252dd42a745cc2c2033b5bb5c9eab806.jpg)

##16. 如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)
解法一：暴力移位法
解法二：三步反转法(异或)

1. 首先将原字符串分为两个部分，即X:abc，Y:def；
2. 将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
3. 反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。
 
##17. 如何最快地判断字符串B中所有字母是否都在字符串A里？
解法一：逐个比较<br>
解法二：可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询<br>
解法三：素数<br>

1. 按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。
2. 遍历长字符串，求得每个字符对应素数的乘积。
3. 遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。
4. 输出结果。

##18. 计数排序

计数排序的思想是对每一个输入元素x，确定出小于x的元素个数，有了这一信息，就可以把x直接放在它在最终输出数组的位置上，例如，如果有17个元素小于x，则x就是属于第18个输出位置。当几个元素相同是，方案要略作修改。

##19. 输入字符串"123"，输出整数123

解法一：<br>

1. 当我们扫描到字符串的第一个字符'1'时，由于我们知道这是第一位，所以得到数字1。
2. 当扫描到第二个数字'2'时，而之前我们知道前面有一个1，所以便在后面加上一个数字2，那前面的1相当于10，因此得到数字：1 * 10 + 2 = 12。
3. 继续扫描到字符'3'，'3'的前面已经有了12，由于前面的12相当于120，加上后面扫描到的3，最终得到的数是：12 * 10 + 3 = 123。
 
##20. 判断一个字串是否是回文？
解法一：<br>

* 同时从字符串头尾开始向中间扫描字串，如果所有字符都一样，那么这个字串就是一个回文。采用这种方法的话，我们只需要维护头部和尾部两个扫描指针即可。<br>
解法二：<br>
可以先从中间开始、然后向两边扩展查看字符是否相等。

1. 判断一条单向链表是不是“回文”
分析：对于单链表结构，可以用两个指针从两端或者中间遍历并判断对应字符是否相等。但这里的关键就是如何朝两个方向遍历。由于单链表是单向的，所以要向两个方向遍历的话，可以采取经典的快慢指针的方法，即先位到链表的中间位置，再将链表的后半逆置，最后用两个指针同时从链表头部和中间开始同时遍历并比较即可。
2. 判断一个栈是不是“回文”
分析：对于栈的话，只需要将字符串全部压入栈，然后依次将各字符出栈，这样得到的就是原字符串的逆置串，分别和原字符串各个字符比较，就可以判断了。

##21. 给定一个字符串，求它的最长回文子串的长度

解法一：<br>
最容易想到的办法是枚举所有的子串，分别判断其是否为回文

##22. 输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串

abc、acb、bac、bca、cab 和 cba。
解法一、递归实现

	1.固定a，求后面bc的排列：abc，acb，求好后，a和b交换，得到bac
	2.固定b，求后面ac的排列：bac，bca，求好后，c放到第一位置，得到cba
	3.固定c，求后面ba的排列：cba，cab。
		
##23. 输入n个整数，输出其中最小的k个

解法一: 快速排序<br>
解法二:用选择或交换排序<br>

1. 遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；
2. 对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））；
3. 继续遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果x < kmax ，用x替换kmax，并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组。

##24. 输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，输出任意一对即可。例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11

解法一：<br>
原始序列： - 1、 2、 4、 7、11、15
用输入数字15减一下各个数，得到对应的序列为： - 14、13、11、8、4、 0
第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描，如果第一个数组出现了和第二个数组一样的数，即a[i]=a[j]，就找出这俩个数来了。 如上，i，j最终在第一个，和第二个序列中找到了相同的数4和11，所以符合条件的两个数，即为4+11=15。 怎么样，两端同时查找，时间复杂度瞬间缩短到了O(N)，但却同时需要O(N)的空间存储第二个数组。
解法二：hash表

##25. 一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。求总共有多少总跳法，并分析算法的时间复杂度

解法一：斐波那契 递归

##26. 给定一个有序的数组，查找某个数是否在数组中

解法一：二分查找

##27. 数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字

解法：hash表

##28. 关联式容器

因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash_multimap都是基于hashtable之上，所以不含有自动排序功能，至于加个前缀multi_无非就是允许键值重复而已

##29. 海量数据分而治之

换言之，先映射，而后统计，最后排序（堆/归并排序）

##30. 什么是Bit-map，假设我们要对0-7内的5个元素(4,7,2,5,3)排序

所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省

![img](https://github.com/hong4cong/hong4cong.github.io/raw/master/images/2015.11.09/bit-map.gif)

##31. 倒排索引

倒排索引是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射，常被应用于搜索引擎和关键字查询的问题中

	T0 = "it is what it is"  
	T1 = "what is it"  
	T2 = "it is a banana"  
	反向文件索引
	"a":      {2}
	"banana": {2}
	"is":     {0, 1, 2}
	"it":     {0, 1, 2}
	"what":   {0, 1}

##32. 简单阐述TCP连接的三次握手

SYN:请求同步/同步序列号 ACK:应答同步/确认字段
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

##33. 线性表是零个或多个具有相同类型的数据元素的有限序列

线性表的两大结构顺序存储结构和链式存储 结构

##34. 栈( stack )是限定仅在表尾进行插入和删除操作的线性表

队列 ( queue ) 是只允许在一端进行插入操作,而在另 -端进行删除操 作的线性表

##35. 字符串的KMP匹配算法

[KMP匹配算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

##36. 二叉树

![img](https://github.com/hong4cong/hong4cong.github.io/raw/master/images/2015.11.09/PastedGraphic.jpg)

##37. 二叉树遍历方法

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历
 
##38. Huffman tree(赫夫曼树、霍夫曼树、哈夫曼树、最优二叉树是压缩和解压算法的基础)

[赫夫曼算法](http://blog.csdn.net/flyfish1986/article/details/47192277)描述:

1. 根据给定的n个权值{Wl,响,...,Wn}构成n棵二叉树的集合F={Tl,T2,...几}, 其中每棵二叉树 Ti 中只有一个带权为 Wi根结点,其左右子树均为空 。
2. 在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树,且 置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
3. 在F中删除这两棵树,同时将新得到的二叉树加入F中。4. 重复 2 和 3 步骤,直到 F 只含一棵树为止。这棵树便是赫夫曼树。
 
##39. 我们把构造连通网的最小代价生成树 称为最小生成树

![img](https://github.com/hong4cong/hong4cong.github.io/raw/master/images/2015.11.09/PastedGraphic2.jpg)

##40. 排序算法

1. 冒泡排序
2. 简单选择排序：简单选择排序法 (Simp坠 Selection Sort) 就是通过 n- i 次关键字间的比较,从n-j+1个记录中选出关键字最小的记录,并和第 i (1<i<;n) 个记录交换之。
3. 直接插入排序的基本操作是将 一个记录插入到已经排 好序的有序表中,从而得到一个新的、记录数增 1 的有序表。
4. 希尔排序：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。
5. 堆排序：堆排序 就是利用堆(假设利用大顶堆)进行排序的方法。它的基本 思想是, 将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根 结点。将它移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大 值) .然后将剩余的 n-1 个序列重新构造成一个堆,这样就刽寻到 n 个元素中的次小 值。如此反复执行, 便能得到一个有序序列了
6. 归并排序：<br>
 ![img1] 
7. 快速排序：快速排序 (Quick Sort) 的基本思想是:通过一趟排序将待排记录分割成独立的 两部分,其中一部分记录的关键字均比另 一部分记录的关键字小,则可分别对这两部 分记录继续进行排序,以达到整个序列有序的目的
 
[img1]: https://github.com/hong4cong/hong4cong.github.io/raw/master/images/2015.11.09/PastedGraphic3.jpg

##41. IOS 消息机制
iOS 提供了一种 "同步的" 消息通知机制，观察者只要向消息中心注册， 即可接受其他对象发送来的消息，消息发送者和消息接受者两者可以互相一无所知，完全解耦。

##42. Block