---
layout: post
title:  "IOS-面试汇总"
date:   2015-11-08 10:23:32
categories: IOS
---

###1. abcdefasdefwefwefw中adc出现的次数
hashmap
 
###2. 10个员工中快速找出 年纪最大的员工
`堆排序`

堆排序 (Heap 80忱) 就是利用堆(假设利用大顶堆)进行排序的方法。它的基本 思想是, 将待排序的序列构造成一个大顶堆。此时,整个序列的最大值就是堆顶的根 结点。将官移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大 值) .然后将剩余的 n-1 个序列重新构造成一个堆,这样就刽寻到 n 个元素中的次小 值。如此反复执行, 便能得到一个有序序列了。

###3. 2万个员工中取年纪最大的前10个
* 快速排序
* 堆排序
 
###4. map和NSdic的底层实现
map `红黑树`

###5. http协议中 判断用户头像是否有更新的方法有那些
If-None-Match和`ETag`一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(`ETag`的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和`Etag`

###6. http中文件断点下载的实现机制
实际上断点续传的实现非常简单，只要在请求中加一个Range字段就可以了。 
假如一个文件有1000个字节，那么其范围就是0-999，则： 
Range: bytes=500-      表示读取该文件的500-999字节，共500字节。 
Range: bytes=500-599   表示读取该文件的500-599字节，共100字节。 
Range还有其它几种写法，但上面这两种是最常用的，对于断点续传也足矣了。如果HTTP请求中包含Range字段，那么服务器会返回206（Partial Content），同时HTTP头中也会有一个相应的Content-Range字段，类似下面的格式：
Content-Range: bytes 500-999/1000 
Content-Range字段说明服务器返回了文件的某个范围及文件的总长度。这时Content-Length字段就不是整个文件的大小了，而是对应文件这个范围的字节数，这一点一定要注意。
###7. 怎么与服务器商定可变参数的协议
参数前带个标示

###8. iOS用户响应者链剖析
[响应链]简单来说就是:一级一级的找到响应的视图,如果没有就传给UIWindow实例和UIApplication实例,要是他们也处理不了,就丢弃这次事件...

[响应链]: http://www.cnblogs.com/mcj-coding/p/3569908.html

###9. instrument中检测图片透明度
coreAnimation

###10. IOS混编C++ C++中如果有数组越界了 怎么快速定位
lldb

###11. IOS中野指针怎么快速定位
IOS提供了一个环境变量设置来帮忙定位错误位置的信息描述：NSZombieEnabled ，就是当设置NSZombieEnabled环境变量后，一个对象销毁时会被转化为_NSZombie，设置NSZombieEnabled后，当你向一个已经释放的对象发送消息，这个对象就不会向之前那样Crash或者产生一个难以理解的行为，而是放出一个错误消息，然后以一种可预测的可以产生debug断点的方式消失， 因此我们就可以找到具体或者大概是哪个对象被错误的释放了。

###12. IOS中app切到后台后,怎么实现的继续导航
[application beginBackgroundTaskWithExpirationHandler:]

###13. IOS 推送机制
Apple Push Notification Service
1. 首先是应用程序注册消息推送。
2. IOS跟APNS Server要deviceToken。应用程序接受deviceToken。
3. 应用程序将deviceToken发送给PUSH服务端程序。
4. 服务端程序向APNS服务发送消息。
5. APNS服务将消息发送给iPhone应用程序。
 
###14. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析
方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n * le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n * lg10)。所以总的时间复杂度，是O(n * le)与O(n * lg10)中较大的哪一个。

###15. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？
方案1：这题用trie树比较合适，hash_map也应该能行。
![image](https://github.com/hong4cong/hong4cong.github.io/raw/master/images/2015.11.09/d62a6059252dd42a745cc2c2033b5bb5c9eab806.jpg)

###16. 如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)
解法一：暴力移位法
解法二：三步反转法(异或)

1. 首先将原字符串分为两个部分，即X:abc，Y:def；
2. 将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
3. 反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。
